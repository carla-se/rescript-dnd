// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml from "rescript/lib/es6/caml.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as React from "react";
import * as Belt_Id from "rescript/lib/es6/belt_Id.js";
import * as Belt_Map from "rescript/lib/es6/belt_Map.js";
import * as Js_array from "rescript/lib/es6/js_array.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Dnd__Style from "./Dnd__Style.bs.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Dnd__Events from "./Dnd__Events.bs.js";
import * as Dnd__Geometry from "./Dnd__Geometry.bs.js";
import * as Dnd__Scroller from "./Dnd__Scroller.bs.js";
import * as Belt_SortArray from "rescript/lib/es6/belt_SortArray.js";
import * as Dnd__Scrollable from "./Dnd__Scrollable.bs.js";

function Make(Context) {
  var Item = Context.Item;
  var Container = Context.Container;
  var ComparableItem = Belt_Id.MakeComparable({
        cmp: Item.cmp
      });
  var ComparableContainer = Belt_Id.MakeComparable({
        cmp: Container.cmp
      });
  var calculateDeltaToLandGhostBeforeItem = function (axis, scroll, scrollableDelta, itemRect, itemGeometry, ghostMargins, ghostDepartureRect, ghostDeparturePoint) {
    if (axis) {
      return {
              x: itemRect.page.left - ghostDepartureRect.page.left - (scroll.delta.x + scrollableDelta.x),
              y: itemRect.page.top - (itemGeometry.margins.top + ghostMargins.bottom) - (ghostDepartureRect.page.bottom - ghostDeparturePoint.page.y) - ghostDeparturePoint.page.y
            };
    } else {
      return {
              x: itemRect.page.left - (itemGeometry.margins.left + ghostMargins.right) - (ghostDepartureRect.page.right - ghostDeparturePoint.page.x) - ghostDeparturePoint.page.x,
              y: itemRect.page.top - ghostDepartureRect.page.top - (scroll.delta.y + scrollableDelta.y)
            };
    }
  };
  var calculateDeltaToLandGhostAfterItem = function (axis, scroll, scrollableDelta, itemRect, itemGeometry, ghostMargins, ghostDepartureRect, ghostDeparturePoint) {
    if (axis) {
      return {
              x: itemRect.page.left - ghostDepartureRect.page.left - (scroll.delta.x + scrollableDelta.x),
              y: itemRect.page.bottom + (itemGeometry.margins.bottom + ghostMargins.top) + (ghostDeparturePoint.page.y - ghostDepartureRect.page.top) - ghostDeparturePoint.page.y
            };
    } else {
      return {
              x: itemRect.page.right + (itemGeometry.margins.right + ghostMargins.left) + (ghostDeparturePoint.page.x - ghostDepartureRect.page.left) - ghostDeparturePoint.page.x,
              y: itemRect.page.top - ghostDepartureRect.page.top - (scroll.delta.y + scrollableDelta.y)
            };
    }
  };
  var calculateDeltaToLandGhostOnEmptyContainer = function (axis, containerGeometry, ghostDimensions, ghostDepartureRect, ghostDeparturePoint) {
    if (axis) {
      return {
              x: containerGeometry.rect.page.left + (containerGeometry.borders.left + containerGeometry.paddings.left) + (ghostDeparturePoint.page.x - ghostDepartureRect.page.left) - ghostDeparturePoint.page.x,
              y: containerGeometry.rect.page.bottom - (containerGeometry.borders.bottom + containerGeometry.paddings.bottom) - (ghostDepartureRect.page.bottom - ghostDeparturePoint.page.y) + ghostDimensions.height - ghostDeparturePoint.page.y
            };
    } else {
      return {
              x: containerGeometry.rect.page.right - (containerGeometry.borders.right + containerGeometry.paddings.right) - (ghostDepartureRect.page.right - ghostDeparturePoint.page.x) + ghostDimensions.width - ghostDeparturePoint.page.x,
              y: containerGeometry.rect.page.top + (containerGeometry.borders.top + containerGeometry.paddings.top) + (ghostDeparturePoint.page.y - ghostDepartureRect.page.top) - ghostDeparturePoint.page.y
            };
    }
  };
  var Layout = {
    calculateDeltaToLandGhostBeforeItem: calculateDeltaToLandGhostBeforeItem,
    calculateDeltaToLandGhostAfterItem: calculateDeltaToLandGhostAfterItem,
    calculateDeltaToLandGhostOnEmptyContainer: calculateDeltaToLandGhostOnEmptyContainer
  };
  var onMouseMove = function (updatePosition, $$event) {
    $$event.preventDefault();
    Curry._1(updatePosition.current, {
          page: {
            x: $$event.pageX,
            y: $$event.pageY
          },
          viewport: {
            x: $$event.clientX,
            y: $$event.clientY
          }
        });
  };
  var onMouseUp = function (startDropping, _event) {
    Curry._1(startDropping.current, undefined);
  };
  var onKeyDown = function (cancelDrag, $$event) {
    var match = Curry._1(Dnd__Events.Keyboard.Dom.key, $$event);
    if (match !== 0) {
      return ;
    } else {
      $$event.stopPropagation();
      return Curry._1(cancelDrag.current, undefined);
    }
  };
  var onResize = function (cancelDrag, _event) {
    Curry._1(cancelDrag.current, undefined);
  };
  var onVisibilityChange = function (cancelDrag, _event) {
    Curry._1(cancelDrag.current, undefined);
  };
  var MouseSubscriptions = {
    onMouseMove: onMouseMove,
    onMouseUp: onMouseUp,
    onKeyDown: onKeyDown,
    onResize: onResize,
    onVisibilityChange: onVisibilityChange
  };
  var onTouchMove = function (updatePosition, $$event) {
    var touch = $$event.touches[0];
    Curry._1(updatePosition.current, {
          page: {
            x: touch.pageX,
            y: touch.pageY
          },
          viewport: {
            x: touch.clientX,
            y: touch.clientY
          }
        });
  };
  var onTouchEnd = function (startDropping, $$event) {
    $$event.preventDefault();
    Curry._1(startDropping.current, undefined);
  };
  var onContextMenu = function ($$event) {
    $$event.preventDefault();
  };
  var onOrientationChange = function (cancelDrag, _event) {
    Curry._1(cancelDrag.current, undefined);
  };
  var onVisibilityChange$1 = function (cancelDrag, _event) {
    Curry._1(cancelDrag.current, undefined);
  };
  var TouchSubscriptions = {
    onTouchMove: onTouchMove,
    onTouchEnd: onTouchEnd,
    onContextMenu: onContextMenu,
    onOrientationChange: onOrientationChange,
    onVisibilityChange: onVisibilityChange$1
  };
  var invoke = function (fn, itemId) {
    if (fn !== undefined) {
      return Curry._1(fn, itemId);
    }
    
  };
  var Hook = {
    invoke: invoke
  };
  var Dnd__DndManager$Make = function (Props) {
    var onDragStart = Props.onDragStart;
    var onDropStart = Props.onDropStart;
    var onDropEnd = Props.onDropEnd;
    var onReorder = Props.onReorder;
    var children = Props.children;
    var items = React.useRef(Belt_Map.make(ComparableItem));
    var containers = React.useRef(Belt_Map.make(ComparableContainer));
    var scroll = React.useRef(undefined);
    var viewport = React.useRef(undefined);
    var focusTargetToRestore = React.useRef(undefined);
    var scheduledWindowScrollFrameId = React.useRef(undefined);
    var scheduledScrollableElementScrollFrameId = React.useRef(undefined);
    var updateGhostPosition = React.useRef(function (_point) {
          
        });
    var updateScrollPosition = React.useRef(function (_ghost) {
          
        });
    var invalidateLayout = React.useRef(function (_ghost) {
          
        });
    var startDropping = React.useRef(function (param) {
          
        });
    var cancelDrag = React.useRef(function (param) {
          
        });
    var match = React.useReducer((function (state, action) {
            if (typeof action === "number") {
              switch (action) {
                case /* StartDropping */0 :
                    var match = state.status;
                    if (typeof match === "number") {
                      return state;
                    }
                    if (match.TAG !== /* Dragging */1) {
                      return state;
                    }
                    var ghost = match._0;
                    var targetContainerId = ghost.targetContainer;
                    var match$1;
                    if (targetContainerId !== undefined) {
                      var targetContainerId$1 = Caml_option.valFromOption(targetContainerId);
                      if (ghost.targetingOriginalContainer) {
                        var container = Belt_Map.getExn(containers.current, targetContainerId$1);
                        var scroll$1 = Belt_Option.getExn(scroll.current);
                        var scrollable = container.scrollable;
                        var scrollableDelta = scrollable !== undefined ? ({
                              x: scrollable.scroll.delta.x,
                              y: scrollable.scroll.delta.y
                            }) : ({
                              x: 0,
                              y: 0
                            });
                        var items$1 = Belt_SortArray.stableSortBy(Belt_Map.reduce(Belt_Map.keep(items.current, (function (param, item) {
                                        if (Curry._2(Container.eq, item.containerId, targetContainerId$1)) {
                                          return !Curry._2(Item.eq, item.id, ghost.itemId);
                                        } else {
                                          return false;
                                        }
                                      })), [], (function (acc, param, item) {
                                    Js_array.push(item, acc);
                                    return acc;
                                  })), (function (i1, i2) {
                                return Caml.int_compare(i1.originalIndex, i2.originalIndex);
                              }));
                        var before = Belt_Array.reduce(items$1, undefined, (function (res, item) {
                                var match = item.shift;
                                if (res !== undefined) {
                                  if (res.NAME === "SearchingForLastAlphaItem") {
                                    if (match !== undefined) {
                                      if (match) {
                                        return res;
                                      } else {
                                        return {
                                                NAME: "SearchingForLastAlphaItem",
                                                VAL: item
                                              };
                                      }
                                    } else {
                                      return {
                                              NAME: "NextItemAfterLastAlphaFound",
                                              VAL: item
                                            };
                                    }
                                  } else {
                                    return res;
                                  }
                                } else if (match !== undefined) {
                                  if (match) {
                                    return {
                                            NAME: "FirstOmegaItemFound",
                                            VAL: item
                                          };
                                  } else {
                                    return {
                                            NAME: "SearchingForLastAlphaItem",
                                            VAL: item
                                          };
                                  }
                                } else {
                                  return res;
                                }
                              }));
                        if (before !== undefined) {
                          if (before.NAME === "SearchingForLastAlphaItem") {
                            var item = before.VAL;
                            var itemGeometry = Belt_Option.getExn(item.geometry);
                            var itemRect = Dnd__Geometry.shiftInternalSibling(ghost.axis, ghost.dimensions, itemGeometry, scroll$1, container.scrollable, item.shift);
                            match$1 = [
                              {
                                element: ghost.element,
                                itemId: ghost.itemId,
                                originalContainer: ghost.originalContainer,
                                targetContainer: ghost.targetContainer,
                                targetingOriginalContainer: ghost.targetingOriginalContainer,
                                axis: ghost.axis,
                                lockAxis: ghost.lockAxis,
                                direction: ghost.direction,
                                dimensions: ghost.dimensions,
                                margins: ghost.margins,
                                borders: ghost.borders,
                                delta: calculateDeltaToLandGhostAfterItem(ghost.axis, scroll$1, scrollableDelta, itemRect, itemGeometry, ghost.margins, ghost.departureRect, ghost.departurePoint),
                                departurePoint: ghost.departurePoint,
                                currentPoint: ghost.currentPoint,
                                departureRect: ghost.departureRect,
                                currentRect: ghost.currentRect
                              },
                              {
                                TAG: /* SameContainer */0,
                                _0: ghost.itemId,
                                _1: /* Last */0
                              }
                            ];
                          } else {
                            var item$1 = before.VAL;
                            var itemGeometry$1 = Belt_Option.getExn(item$1.geometry);
                            var itemRect$1 = Dnd__Geometry.shiftInternalSibling(ghost.axis, ghost.dimensions, itemGeometry$1, scroll$1, container.scrollable, item$1.shift);
                            match$1 = [
                              {
                                element: ghost.element,
                                itemId: ghost.itemId,
                                originalContainer: ghost.originalContainer,
                                targetContainer: ghost.targetContainer,
                                targetingOriginalContainer: ghost.targetingOriginalContainer,
                                axis: ghost.axis,
                                lockAxis: ghost.lockAxis,
                                direction: ghost.direction,
                                dimensions: ghost.dimensions,
                                margins: ghost.margins,
                                borders: ghost.borders,
                                delta: calculateDeltaToLandGhostBeforeItem(ghost.axis, scroll$1, scrollableDelta, itemRect$1, itemGeometry$1, ghost.margins, ghost.departureRect, ghost.departurePoint),
                                departurePoint: ghost.departurePoint,
                                currentPoint: ghost.currentPoint,
                                departureRect: ghost.departureRect,
                                currentRect: ghost.currentRect
                              },
                              {
                                TAG: /* SameContainer */0,
                                _0: ghost.itemId,
                                _1: /* Before */{
                                  _0: item$1.id
                                }
                              }
                            ];
                          }
                        } else {
                          match$1 = [
                            {
                              element: ghost.element,
                              itemId: ghost.itemId,
                              originalContainer: ghost.originalContainer,
                              targetContainer: ghost.targetContainer,
                              targetingOriginalContainer: ghost.targetingOriginalContainer,
                              axis: ghost.axis,
                              lockAxis: ghost.lockAxis,
                              direction: ghost.direction,
                              dimensions: ghost.dimensions,
                              margins: ghost.margins,
                              borders: ghost.borders,
                              delta: {
                                x: -scrollableDelta.x,
                                y: -scrollableDelta.y
                              },
                              departurePoint: ghost.departurePoint,
                              currentPoint: ghost.currentPoint,
                              departureRect: ghost.departureRect,
                              currentRect: ghost.currentRect
                            },
                            undefined
                          ];
                        }
                      } else {
                        var container$1 = Belt_Map.getExn(containers.current, targetContainerId$1);
                        var scroll$2 = Belt_Option.getExn(scroll.current);
                        var scrollable$1 = container$1.scrollable;
                        var scrollableDelta$1 = scrollable$1 !== undefined ? ({
                              x: scrollable$1.scroll.delta.x,
                              y: scrollable$1.scroll.delta.y
                            }) : ({
                              x: 0,
                              y: 0
                            });
                        var items$2 = Belt_SortArray.stableSortBy(Belt_Map.reduce(Belt_Map.keep(items.current, (function (param, item) {
                                        if (Curry._2(Container.eq, item.containerId, targetContainerId$1)) {
                                          return !Curry._2(Item.eq, item.id, ghost.itemId);
                                        } else {
                                          return false;
                                        }
                                      })), [], (function (acc, param, item) {
                                    Js_array.push(item, acc);
                                    return acc;
                                  })), (function (i1, i2) {
                                return Caml.int_compare(i1.originalIndex, i2.originalIndex);
                              }));
                        var before$1 = Belt_Array.reduce(items$2, undefined, (function (res, item) {
                                var match = item.shift;
                                if (res !== undefined || !(match !== undefined && match)) {
                                  return res;
                                } else {
                                  return item;
                                }
                              }));
                        if (before$1 !== undefined) {
                          var itemGeometry$2 = Belt_Option.getExn(before$1.geometry);
                          var itemRect$2 = Dnd__Geometry.shiftExternalSibling(ghost.axis, ghost.dimensions, itemGeometry$2, scroll$2, container$1.scrollable, before$1.shift);
                          match$1 = [
                            {
                              element: ghost.element,
                              itemId: ghost.itemId,
                              originalContainer: ghost.originalContainer,
                              targetContainer: ghost.targetContainer,
                              targetingOriginalContainer: ghost.targetingOriginalContainer,
                              axis: ghost.axis,
                              lockAxis: ghost.lockAxis,
                              direction: ghost.direction,
                              dimensions: ghost.dimensions,
                              margins: ghost.margins,
                              borders: ghost.borders,
                              delta: calculateDeltaToLandGhostBeforeItem(ghost.axis, scroll$2, scrollableDelta$1, itemRect$2, itemGeometry$2, ghost.margins, ghost.departureRect, ghost.departurePoint),
                              departurePoint: ghost.departurePoint,
                              currentPoint: ghost.currentPoint,
                              departureRect: ghost.departureRect,
                              currentRect: ghost.currentRect
                            },
                            {
                              TAG: /* NewContainer */1,
                              _0: ghost.itemId,
                              _1: targetContainerId$1,
                              _2: /* Before */{
                                _0: before$1.id
                              }
                            }
                          ];
                        } else {
                          var item$2 = Belt_Array.get(items$2, items$2.length - 1 | 0);
                          if (item$2 !== undefined) {
                            var itemGeometry$3 = Belt_Option.getExn(item$2.geometry);
                            var itemRect$3 = Dnd__Geometry.shiftExternalSibling(ghost.axis, ghost.dimensions, itemGeometry$3, scroll$2, container$1.scrollable, item$2.shift);
                            match$1 = [
                              {
                                element: ghost.element,
                                itemId: ghost.itemId,
                                originalContainer: ghost.originalContainer,
                                targetContainer: ghost.targetContainer,
                                targetingOriginalContainer: ghost.targetingOriginalContainer,
                                axis: ghost.axis,
                                lockAxis: ghost.lockAxis,
                                direction: ghost.direction,
                                dimensions: ghost.dimensions,
                                margins: ghost.margins,
                                borders: ghost.borders,
                                delta: calculateDeltaToLandGhostAfterItem(ghost.axis, scroll$2, scrollableDelta$1, itemRect$3, itemGeometry$3, ghost.margins, ghost.departureRect, ghost.departurePoint),
                                departurePoint: ghost.departurePoint,
                                currentPoint: ghost.currentPoint,
                                departureRect: ghost.departureRect,
                                currentRect: ghost.currentRect
                              },
                              {
                                TAG: /* NewContainer */1,
                                _0: ghost.itemId,
                                _1: targetContainerId$1,
                                _2: /* Last */0
                              }
                            ];
                          } else {
                            match$1 = [
                              {
                                element: ghost.element,
                                itemId: ghost.itemId,
                                originalContainer: ghost.originalContainer,
                                targetContainer: ghost.targetContainer,
                                targetingOriginalContainer: ghost.targetingOriginalContainer,
                                axis: ghost.axis,
                                lockAxis: ghost.lockAxis,
                                direction: ghost.direction,
                                dimensions: ghost.dimensions,
                                margins: ghost.margins,
                                borders: ghost.borders,
                                delta: calculateDeltaToLandGhostOnEmptyContainer(ghost.axis, Belt_Option.getExn(container$1.geometry), ghost.dimensions, ghost.departureRect, ghost.departurePoint),
                                departurePoint: ghost.departurePoint,
                                currentPoint: ghost.currentPoint,
                                departureRect: ghost.departureRect,
                                currentRect: ghost.currentRect
                              },
                              {
                                TAG: /* NewContainer */1,
                                _0: ghost.itemId,
                                _1: targetContainerId$1,
                                _2: /* Last */0
                              }
                            ];
                          }
                        }
                      }
                    } else {
                      var container$2 = Belt_Map.getExn(containers.current, ghost.originalContainer);
                      var scrollable$2 = container$2.scrollable;
                      var scrollableDelta$2 = scrollable$2 !== undefined ? ({
                            x: scrollable$2.scroll.delta.x,
                            y: scrollable$2.scroll.delta.y
                          }) : ({
                            x: 0,
                            y: 0
                          });
                      var match$2 = ghost.axis;
                      var nextGhost_element = ghost.element;
                      var nextGhost_itemId = ghost.itemId;
                      var nextGhost_originalContainer = ghost.originalContainer;
                      var nextGhost_targetContainer = ghost.targetContainer;
                      var nextGhost_targetingOriginalContainer = ghost.targetingOriginalContainer;
                      var nextGhost_axis = ghost.axis;
                      var nextGhost_lockAxis = ghost.lockAxis;
                      var nextGhost_direction = ghost.direction;
                      var nextGhost_dimensions = ghost.dimensions;
                      var nextGhost_margins = ghost.margins;
                      var nextGhost_borders = ghost.borders;
                      var nextGhost_delta = match$2 ? ({
                            x: 0,
                            y: -scrollableDelta$2.y
                          }) : ({
                            x: -scrollableDelta$2.x,
                            y: 0
                          });
                      var nextGhost_departurePoint = ghost.departurePoint;
                      var nextGhost_currentPoint = ghost.currentPoint;
                      var nextGhost_departureRect = ghost.departureRect;
                      var nextGhost_currentRect = ghost.currentRect;
                      var nextGhost = {
                        element: nextGhost_element,
                        itemId: nextGhost_itemId,
                        originalContainer: nextGhost_originalContainer,
                        targetContainer: nextGhost_targetContainer,
                        targetingOriginalContainer: nextGhost_targetingOriginalContainer,
                        axis: nextGhost_axis,
                        lockAxis: nextGhost_lockAxis,
                        direction: nextGhost_direction,
                        dimensions: nextGhost_dimensions,
                        margins: nextGhost_margins,
                        borders: nextGhost_borders,
                        delta: nextGhost_delta,
                        departurePoint: nextGhost_departurePoint,
                        currentPoint: nextGhost_currentPoint,
                        departureRect: nextGhost_departureRect,
                        currentRect: nextGhost_currentRect
                      };
                      match$1 = [
                        nextGhost,
                        undefined
                      ];
                    }
                    return {
                            status: {
                              TAG: /* Dropping */2,
                              _0: match$1[0],
                              _1: match$1[1]
                            },
                            prevStatus: state.status
                          };
                case /* CancelDrag */1 :
                    var match$3 = state.status;
                    if (typeof match$3 === "number") {
                      return state;
                    }
                    if (match$3.TAG !== /* Dragging */1) {
                      return state;
                    }
                    var ghost$1 = match$3._0;
                    var container$3 = Belt_Map.getExn(containers.current, ghost$1.originalContainer);
                    var scrollable$3 = container$3.scrollable;
                    var nextGhost$1 = scrollable$3 !== undefined ? ({
                          element: ghost$1.element,
                          itemId: ghost$1.itemId,
                          originalContainer: ghost$1.originalContainer,
                          targetContainer: ghost$1.targetContainer,
                          targetingOriginalContainer: ghost$1.targetingOriginalContainer,
                          axis: ghost$1.axis,
                          lockAxis: ghost$1.lockAxis,
                          direction: ghost$1.direction,
                          dimensions: ghost$1.dimensions,
                          margins: ghost$1.margins,
                          borders: ghost$1.borders,
                          delta: {
                            x: -scrollable$3.scroll.delta.x,
                            y: -scrollable$3.scroll.delta.y
                          },
                          departurePoint: ghost$1.departurePoint,
                          currentPoint: ghost$1.currentPoint,
                          departureRect: ghost$1.departureRect,
                          currentRect: ghost$1.currentRect
                        }) : ({
                          element: ghost$1.element,
                          itemId: ghost$1.itemId,
                          originalContainer: ghost$1.originalContainer,
                          targetContainer: ghost$1.targetContainer,
                          targetingOriginalContainer: ghost$1.targetingOriginalContainer,
                          axis: ghost$1.axis,
                          lockAxis: ghost$1.lockAxis,
                          direction: ghost$1.direction,
                          dimensions: ghost$1.dimensions,
                          margins: ghost$1.margins,
                          borders: ghost$1.borders,
                          delta: {
                            x: 0,
                            y: 0
                          },
                          departurePoint: ghost$1.departurePoint,
                          currentPoint: ghost$1.currentPoint,
                          departureRect: ghost$1.departureRect,
                          currentRect: ghost$1.currentRect
                        });
                    return {
                            status: {
                              TAG: /* Dropping */2,
                              _0: nextGhost$1,
                              _1: undefined
                            },
                            prevStatus: state.status
                          };
                case /* Reset */2 :
                    return {
                            status: /* StandBy */0,
                            prevStatus: state.status
                          };
                
              }
            } else {
              switch (action.TAG | 0) {
                case /* CollectEntries */0 :
                    return {
                            status: {
                              TAG: /* Collecting */0,
                              _0: action._0,
                              _1: action._1,
                              _2: action._2,
                              _3: action._3,
                              _4: action._4
                            },
                            prevStatus: state.status
                          };
                case /* StartDragging */1 :
                    return {
                            status: {
                              TAG: /* Dragging */1,
                              _0: action._0,
                              _1: action._1
                            },
                            prevStatus: state.status
                          };
                case /* UpdateGhostPosition */2 :
                    var match$4 = state.status;
                    if (typeof match$4 === "number" || match$4.TAG !== /* Dragging */1) {
                      return state;
                    } else {
                      return {
                              status: {
                                TAG: /* Dragging */1,
                                _0: action._0,
                                _1: match$4._1
                              },
                              prevStatus: state.status
                            };
                    }
                
              }
            }
          }), {
          status: /* StandBy */0,
          prevStatus: /* StandBy */0
        });
    var dispatch = match[1];
    var state = match[0];
    var registerItem = React.useCallback((function (item) {
            items.current = Belt_Map.set(items.current, item.id, {
                  id: item.id,
                  containerId: item.containerId,
                  originalIndex: item.index,
                  targetIndex: item.index,
                  element: item.element,
                  shift: undefined,
                  geometry: undefined,
                  animating: false,
                  getGeometry: item.getGeometry
                });
          }), [items]);
    var registerContainer = React.useCallback((function (container) {
            containers.current = Belt_Map.set(containers.current, container.id, {
                  id: container.id,
                  axis: container.axis,
                  lockAxis: container.lockAxis,
                  element: container.element,
                  geometry: undefined,
                  scrollable: undefined,
                  accept: container.accept,
                  getGeometryAndScrollable: container.getGeometryAndScrollable
                });
          }), [containers]);
    var disposeItem = React.useCallback((function (itemId) {
            items.current = Belt_Map.remove(items.current, itemId);
          }), [items]);
    var disposeContainer = React.useCallback((function (containerId) {
            containers.current = Belt_Map.remove(containers.current, containerId);
          }), [containers]);
    var collectEntries = React.useCallback((function (itemId) {
            return function (containerId, startPoint, currentPoint, interaction) {
              return Curry._1(dispatch, {
                          TAG: /* CollectEntries */0,
                          _0: itemId,
                          _1: containerId,
                          _2: startPoint,
                          _3: currentPoint,
                          _4: interaction
                        });
            };
          }), []);
    var prepareDrag = React.useCallback((function (itemId) {
            return function (containerId, startPoint, currentPoint, interaction) {
              var item = Belt_Map.getExn(items.current, itemId);
              var container = Belt_Map.getExn(containers.current, containerId);
              var maxScroll = Dnd__Scrollable.$$Window.getMaxScroll(undefined);
              var scrollPosition = Dnd__Scrollable.$$Window.getScrollPosition(undefined);
              var rect = item.element.getBoundingClientRect();
              var style = window.getComputedStyle(item.element);
              var viewportRect = Dnd__Geometry.getViewportRect(rect);
              var pageRect = Dnd__Geometry.getPageRectFromViewportRect(viewportRect, scrollPosition);
              var currentRect = {
                page: pageRect,
                viewport: viewportRect
              };
              var ghost_element = item.element;
              var ghost_targetContainer = Caml_option.some(containerId);
              var ghost_axis = container.axis;
              var ghost_lockAxis = container.lockAxis;
              var ghost_direction = Dnd__Geometry.getDirection(startPoint.page.y, currentPoint.page.y);
              var ghost_dimensions = Dnd__Geometry.getDimensions(rect);
              var ghost_margins = Dnd__Geometry.getMargins(style);
              var ghost_borders = Dnd__Geometry.getBorders(style);
              var ghost_delta = {
                x: 0,
                y: 0
              };
              var ghost = {
                element: ghost_element,
                itemId: itemId,
                originalContainer: containerId,
                targetContainer: ghost_targetContainer,
                targetingOriginalContainer: true,
                axis: ghost_axis,
                lockAxis: ghost_lockAxis,
                direction: ghost_direction,
                dimensions: ghost_dimensions,
                margins: ghost_margins,
                borders: ghost_borders,
                delta: ghost_delta,
                departurePoint: currentPoint,
                currentPoint: currentPoint,
                departureRect: currentRect,
                currentRect: currentRect
              };
              var subscriptions;
              if (interaction === "Touch") {
                var onTouchMove$1 = function (param) {
                  return onTouchMove(updateGhostPosition, param);
                };
                var onTouchEnd$1 = function (param) {
                  return onTouchEnd(startDropping, param);
                };
                var onOrientationChange = function (param) {
                  return Curry._1(cancelDrag.current, undefined);
                };
                var onVisibilityChange = function (param) {
                  return Curry._1(cancelDrag.current, undefined);
                };
                subscriptions = {
                  install: (function (param) {
                      window.addEventListener("touchmove", onTouchMove$1);
                      window.addEventListener("touchend", onTouchEnd$1);
                      window.addEventListener("contextmenu", onContextMenu);
                      window.addEventListener("orientationchange", onOrientationChange);
                      window.addEventListener("visibilitychange", onVisibilityChange);
                    }),
                  drop: (function (param) {
                      window.removeEventListener("touchmove", onTouchMove$1);
                      window.removeEventListener("touchend", onTouchEnd$1);
                      window.removeEventListener("contextmenu", onContextMenu);
                      window.removeEventListener("orientationchange", onOrientationChange);
                      window.removeEventListener("visibilitychange", onVisibilityChange);
                    })
                };
              } else {
                var onMouseMove$1 = function (param) {
                  return onMouseMove(updateGhostPosition, param);
                };
                var onMouseUp = function (param) {
                  return Curry._1(startDropping.current, undefined);
                };
                var onKeyDown$1 = function (param) {
                  return onKeyDown(cancelDrag, param);
                };
                var onResize = function (param) {
                  return Curry._1(cancelDrag.current, undefined);
                };
                var onVisibilityChange$1 = function (param) {
                  return Curry._1(cancelDrag.current, undefined);
                };
                subscriptions = {
                  install: (function (param) {
                      window.addEventListener("mousemove", onMouseMove$1);
                      window.addEventListener("mouseup", onMouseUp);
                      ghost_element.addEventListener("keydown", onKeyDown$1);
                      window.addEventListener("resize", onResize);
                      window.addEventListener("visibilitychange", onVisibilityChange$1);
                    }),
                  drop: (function (param) {
                      window.removeEventListener("mousemove", onMouseMove$1);
                      window.removeEventListener("mouseup", onMouseUp);
                      ghost_element.removeEventListener("keydown", onKeyDown$1);
                      window.removeEventListener("resize", onResize);
                      window.removeEventListener("visibilitychange", onVisibilityChange$1);
                    })
                };
              }
              items.current = Belt_Map.map(items.current, (function (item) {
                      return {
                              id: item.id,
                              containerId: item.containerId,
                              originalIndex: item.originalIndex,
                              targetIndex: item.targetIndex,
                              element: item.element,
                              shift: item.shift,
                              geometry: Curry._1(item.getGeometry, undefined),
                              animating: item.animating,
                              getGeometry: item.getGeometry
                            };
                    }));
              containers.current = Belt_Map.map(containers.current, (function (container) {
                      var match = Curry._1(container.getGeometryAndScrollable, undefined);
                      return {
                              id: container.id,
                              axis: container.axis,
                              lockAxis: container.lockAxis,
                              element: container.element,
                              geometry: match[0],
                              scrollable: match[1],
                              accept: container.accept,
                              getGeometryAndScrollable: container.getGeometryAndScrollable
                            };
                    }));
              viewport.current = Dnd__Geometry.getViewport(undefined);
              scroll.current = {
                initial: scrollPosition,
                current: scrollPosition,
                delta: {
                  x: 0,
                  y: 0
                },
                max: maxScroll
              };
              focusTargetToRestore.current = Belt_Option.map(Caml_option.nullable_to_opt(document.activeElement), (function (prim) {
                      return prim;
                    }));
              ghost_element.focus();
              return Curry._1(dispatch, {
                          TAG: /* StartDragging */1,
                          _0: ghost,
                          _1: subscriptions
                        });
            };
          }), [
          items,
          containers
        ]);
    var resetAnimationsOnDrag = React.useCallback((function (itemIds) {
            if (itemIds) {
              items.current = Belt_List.reduceU(itemIds, items.current, (function (map, id) {
                      return Belt_Map.updateU(map, id, (function (item) {
                                    if (item !== undefined) {
                                      return {
                                              id: item.id,
                                              containerId: item.containerId,
                                              originalIndex: item.originalIndex,
                                              targetIndex: item.targetIndex,
                                              element: item.element,
                                              shift: item.shift,
                                              geometry: item.geometry,
                                              animating: false,
                                              getGeometry: item.getGeometry
                                            };
                                    }
                                    
                                  }));
                    }));
              return ;
            }
            
          }), [items]);
    React.useEffect((function () {
            var match = state.prevStatus;
            var match$1 = state.status;
            if (typeof match === "number") {
              if (typeof match$1 === "number") {
                return ;
              }
              if (match$1.TAG !== /* Collecting */0) {
                return ;
              }
              Curry._5(prepareDrag, match$1._0, match$1._1, match$1._2, match$1._3, match$1._4);
              return ;
            } else {
              switch (match.TAG | 0) {
                case /* Collecting */0 :
                    if (typeof match$1 === "number") {
                      return ;
                    }
                    if (match$1.TAG !== /* Dragging */1) {
                      return ;
                    }
                    Curry._1(match$1._1.install, undefined);
                    invoke(onDragStart, match$1._0.itemId);
                    return ;
                case /* Dragging */1 :
                    if (typeof match$1 === "number") {
                      return ;
                    }
                    if (match$1.TAG !== /* Dropping */2) {
                      return ;
                    }
                    var result = match$1._1;
                    invoke(onDropStart, match$1._0.itemId);
                    setTimeout((function (param) {
                            Curry._1(onReorder, result);
                            Curry._1(dispatch, /* Reset */2);
                          }), Dnd__Style.animationDuration + Dnd__Style.finishDropFactor | 0);
                    return ;
                case /* Dropping */2 :
                    if (typeof match$1 === "number") {
                      Belt_Option.map(focusTargetToRestore.current, (function (prim) {
                              prim.focus();
                            }));
                      focusTargetToRestore.current = undefined;
                      items.current = Belt_Map.make(ComparableItem);
                      containers.current = Belt_Map.make(ComparableContainer);
                      scroll.current = undefined;
                      viewport.current = undefined;
                      invoke(onDropEnd, match._0.itemId);
                      return ;
                    } else {
                      return ;
                    }
                
              }
            }
          }), [
          state.status,
          state.prevStatus
        ]);
    updateGhostPosition.current = React.useCallback((function (nextPoint) {
            var match = state.status;
            if (typeof match === "number") {
              return ;
            }
            if (match.TAG !== /* Dragging */1) {
              return ;
            }
            var ghost = match._0;
            var nextPoint$1;
            if (ghost.lockAxis) {
              var match$1 = ghost.axis;
              if (match$1) {
                var init = nextPoint.page;
                var init$1 = nextPoint.viewport;
                nextPoint$1 = {
                  page: {
                    x: ghost.departurePoint.page.x,
                    y: init.y
                  },
                  viewport: {
                    x: ghost.departurePoint.viewport.x,
                    y: init$1.y
                  }
                };
              } else {
                var init$2 = nextPoint.page;
                var init$3 = nextPoint.viewport;
                nextPoint$1 = {
                  page: {
                    x: init$2.x,
                    y: ghost.departurePoint.page.y
                  },
                  viewport: {
                    x: init$3.x,
                    y: ghost.departurePoint.viewport.y
                  }
                };
              }
            } else {
              nextPoint$1 = nextPoint;
            }
            var __x = Belt_Map.valuesToArray(containers.current);
            var targetContainer = Belt_Option.map(Js_array.find((function (container) {
                        var geometry = Belt_Option.getExn(container.geometry);
                        var scrollable = container.scrollable;
                        var rect = scrollable !== undefined ? ({
                              top: scrollable.geometry.rect.page.top > geometry.rect.page.top ? scrollable.geometry.rect.page.top : geometry.rect.page.top,
                              bottom: scrollable.geometry.rect.page.bottom < geometry.rect.page.bottom ? scrollable.geometry.rect.page.bottom : geometry.rect.page.bottom,
                              left: scrollable.geometry.rect.page.left > geometry.rect.page.left ? scrollable.geometry.rect.page.left : geometry.rect.page.left,
                              right: scrollable.geometry.rect.page.right < geometry.rect.page.right ? scrollable.geometry.rect.page.right : geometry.rect.page.right
                            }) : geometry.rect.page;
                        if (Belt_Option.getWithDefault(Belt_Option.map(container.accept, (function (accept) {
                                      return Curry._1(accept, ghost.itemId);
                                    })), true)) {
                          return Dnd__Geometry.isWithin(nextPoint$1.page, rect);
                        } else {
                          return false;
                        }
                      }), __x), (function (container) {
                    return container.id;
                  }));
            var targetingOriginalContainer = targetContainer !== undefined && !Curry._2(Container.eq, Caml_option.valFromOption(targetContainer), ghost.originalContainer) ? false : true;
            var nextRect_page = {
              top: ghost.currentRect.page.top + nextPoint$1.page.y - ghost.currentPoint.page.y,
              bottom: ghost.currentRect.page.bottom + nextPoint$1.page.y - ghost.currentPoint.page.y,
              left: ghost.currentRect.page.left + nextPoint$1.page.x - ghost.currentPoint.page.x,
              right: ghost.currentRect.page.right + nextPoint$1.page.x - ghost.currentPoint.page.x
            };
            var nextRect_viewport = {
              top: ghost.currentRect.viewport.top + nextPoint$1.viewport.y - ghost.currentPoint.viewport.y,
              bottom: ghost.currentRect.viewport.bottom + nextPoint$1.viewport.y - ghost.currentPoint.viewport.y,
              left: ghost.currentRect.viewport.left + nextPoint$1.viewport.x - ghost.currentPoint.viewport.x,
              right: ghost.currentRect.viewport.right + nextPoint$1.viewport.x - ghost.currentPoint.viewport.x
            };
            var nextRect = {
              page: nextRect_page,
              viewport: nextRect_viewport
            };
            var match$2 = ghost.axis;
            var nextDirection = match$2 ? Dnd__Geometry.getDirection(ghost.currentPoint.viewport.y, nextPoint$1.viewport.y) : Dnd__Geometry.getDirection(ghost.currentPoint.viewport.x, nextPoint$1.viewport.x);
            Curry._1(invalidateLayout.current, {
                  element: ghost.element,
                  itemId: ghost.itemId,
                  originalContainer: ghost.originalContainer,
                  targetContainer: targetContainer,
                  targetingOriginalContainer: targetingOriginalContainer,
                  axis: ghost.axis,
                  lockAxis: ghost.lockAxis,
                  direction: nextDirection !== undefined ? nextDirection : ghost.direction,
                  dimensions: ghost.dimensions,
                  margins: ghost.margins,
                  borders: ghost.borders,
                  delta: {
                    x: nextPoint$1.page.x - ghost.departurePoint.page.x,
                    y: nextPoint$1.page.y - ghost.departurePoint.page.y
                  },
                  departurePoint: ghost.departurePoint,
                  currentPoint: nextPoint$1,
                  departureRect: ghost.departureRect,
                  currentRect: nextRect
                });
          }), [
          state.status,
          items,
          containers
        ]);
    updateScrollPosition.current = React.useCallback((function (ghost) {
            var scrollable = Belt_Map.reduce(containers.current, undefined, (function (scrollable, param, container) {
                    var match = container.scrollable;
                    if (scrollable !== undefined) {
                      if (match !== undefined && !Dnd__Geometry.contains(match.geometry.rect.page, scrollable.geometry.rect.page)) {
                        return match;
                      } else {
                        return scrollable;
                      }
                    } else if (match !== undefined && Dnd__Geometry.isWithin(ghost.currentPoint.page, match.geometry.rect.page)) {
                      return match;
                    } else {
                      return ;
                    }
                  }));
            var scroller = Dnd__Scroller.getScroller(ghost.currentPoint, Belt_Option.getExn(viewport.current), Belt_Option.getExn(scroll.current), scrollable);
            if (scroller === undefined) {
              return ;
            }
            if (scroller.TAG === /* Window */0) {
              var frameId = scheduledWindowScrollFrameId.current;
              if (frameId !== undefined) {
                cancelAnimationFrame(Caml_option.valFromOption(frameId));
                scheduledWindowScrollFrameId.current = undefined;
              }
              scheduledWindowScrollFrameId.current = Curry._1(scroller._0, (function (param) {
                      var currentScroll = Belt_Option.getExn(scroll.current);
                      var nextScrollPosition = Dnd__Scrollable.$$Window.getScrollPosition(undefined);
                      var nextScroll_initial = currentScroll.initial;
                      var nextScroll_delta = {
                        x: nextScrollPosition.x - currentScroll.initial.x,
                        y: nextScrollPosition.y - currentScroll.initial.y
                      };
                      var nextScroll_max = currentScroll.max;
                      var nextScroll = {
                        initial: nextScroll_initial,
                        current: nextScrollPosition,
                        delta: nextScroll_delta,
                        max: nextScroll_max
                      };
                      var nextPoint_page = {
                        x: ghost.currentPoint.page.x + nextScrollPosition.x - currentScroll.current.x,
                        y: ghost.currentPoint.page.y + nextScrollPosition.y - currentScroll.current.y
                      };
                      var nextPoint_viewport = {
                        x: ghost.currentPoint.viewport.x,
                        y: ghost.currentPoint.viewport.y
                      };
                      var nextPoint = {
                        page: nextPoint_page,
                        viewport: nextPoint_viewport
                      };
                      var delta_x = nextScrollPosition.x - currentScroll.current.x;
                      var delta_y = nextScrollPosition.y - currentScroll.current.y;
                      var delta = {
                        x: delta_x,
                        y: delta_y
                      };
                      containers.current = Belt_Map.map(containers.current, (function (container) {
                              var scrollable = container.scrollable;
                              if (scrollable === undefined) {
                                return {
                                        id: container.id,
                                        axis: container.axis,
                                        lockAxis: container.lockAxis,
                                        element: container.element,
                                        geometry: Belt_Option.map(container.geometry, (function (geometry) {
                                                return {
                                                        rect: Dnd__Geometry.shiftViewportRect(geometry.rect, delta),
                                                        dimensions: geometry.dimensions,
                                                        margins: geometry.margins,
                                                        borders: geometry.borders,
                                                        paddings: geometry.paddings
                                                      };
                                              })),
                                        scrollable: container.scrollable,
                                        accept: container.accept,
                                        getGeometryAndScrollable: container.getGeometryAndScrollable
                                      };
                              }
                              var init = scrollable.geometry;
                              return {
                                      id: container.id,
                                      axis: container.axis,
                                      lockAxis: container.lockAxis,
                                      element: container.element,
                                      geometry: Belt_Option.map(container.geometry, (function (geometry) {
                                              return {
                                                      rect: Dnd__Geometry.shiftViewportRect(geometry.rect, delta),
                                                      dimensions: geometry.dimensions,
                                                      margins: geometry.margins,
                                                      borders: geometry.borders,
                                                      paddings: geometry.paddings
                                                    };
                                            })),
                                      scrollable: {
                                        element: scrollable.element,
                                        geometry: {
                                          rect: Dnd__Geometry.shiftViewportRect(scrollable.geometry.rect, delta),
                                          dimensions: init.dimensions,
                                          margins: init.margins,
                                          borders: init.borders,
                                          paddings: init.paddings
                                        },
                                        scroll: scrollable.scroll
                                      },
                                      accept: container.accept,
                                      getGeometryAndScrollable: container.getGeometryAndScrollable
                                    };
                            }));
                      scroll.current = nextScroll;
                      Curry._1(updateGhostPosition.current, nextPoint);
                    }));
              return ;
            }
            var frameId$1 = scheduledScrollableElementScrollFrameId.current;
            if (frameId$1 !== undefined) {
              cancelAnimationFrame(Caml_option.valFromOption(frameId$1));
              scheduledScrollableElementScrollFrameId.current = undefined;
            }
            scheduledScrollableElementScrollFrameId.current = Curry._1(scroller._0, (function (scrollable) {
                    var nextScrollPosition = Dnd__Scrollable.$$Element.getScrollPosition(scrollable.element);
                    var init = scrollable.scroll;
                    var nextScroll_initial = init.initial;
                    var nextScroll_delta = {
                      x: nextScrollPosition.x - scrollable.scroll.initial.x,
                      y: nextScrollPosition.y - scrollable.scroll.initial.y
                    };
                    var nextScroll_max = init.max;
                    var nextScroll = {
                      initial: nextScroll_initial,
                      current: nextScrollPosition,
                      delta: nextScroll_delta,
                      max: nextScroll_max
                    };
                    var delta_x = nextScrollPosition.x - scrollable.scroll.current.x;
                    var delta_y = nextScrollPosition.y - scrollable.scroll.current.y;
                    var delta = {
                      x: delta_x,
                      y: delta_y
                    };
                    containers.current = Belt_Map.map(containers.current, (function (container) {
                            var scrollable$p = container.scrollable;
                            if (scrollable$p !== undefined) {
                              if (scrollable$p.element === scrollable.element) {
                                return {
                                        id: container.id,
                                        axis: container.axis,
                                        lockAxis: container.lockAxis,
                                        element: container.element,
                                        geometry: Belt_Option.map(container.geometry, (function (geometry) {
                                                return {
                                                        rect: Dnd__Geometry.shiftRects(geometry.rect, delta),
                                                        dimensions: geometry.dimensions,
                                                        margins: geometry.margins,
                                                        borders: geometry.borders,
                                                        paddings: geometry.paddings
                                                      };
                                              })),
                                        scrollable: {
                                          element: scrollable.element,
                                          geometry: scrollable.geometry,
                                          scroll: nextScroll
                                        },
                                        accept: container.accept,
                                        getGeometryAndScrollable: container.getGeometryAndScrollable
                                      };
                              } else if (Dnd__Geometry.contains(scrollable.geometry.rect.page, scrollable$p.geometry.rect.page)) {
                                return {
                                        id: container.id,
                                        axis: container.axis,
                                        lockAxis: container.lockAxis,
                                        element: container.element,
                                        geometry: Belt_Option.map(container.geometry, (function (geometry) {
                                                return {
                                                        rect: Dnd__Geometry.shiftRects(geometry.rect, delta),
                                                        dimensions: geometry.dimensions,
                                                        margins: geometry.margins,
                                                        borders: geometry.borders,
                                                        paddings: geometry.paddings
                                                      };
                                              })),
                                        scrollable: container.scrollable,
                                        accept: container.accept,
                                        getGeometryAndScrollable: container.getGeometryAndScrollable
                                      };
                              } else {
                                return container;
                              }
                            } else {
                              return container;
                            }
                          }));
                    Curry._1(invalidateLayout.current, ghost);
                  }));
          }), [
          items,
          containers
        ]);
    invalidateLayout.current = React.useCallback((function (ghost) {
            var targetContainerId = ghost.targetContainer;
            var match;
            if (targetContainerId !== undefined) {
              var targetContainerId$1 = Caml_option.valFromOption(targetContainerId);
              var container = Belt_Map.getExn(containers.current, targetContainerId$1);
              match = Belt_Map.reduce(items.current, [
                    items.current,
                    /* [] */0
                  ], (function (param, id, item) {
                      var animate = param[1];
                      var items = param[0];
                      var itemContainerId = item.containerId;
                      if (Curry._2(Container.eq, targetContainerId$1, itemContainerId) && ghost.targetingOriginalContainer) {
                        var geometry = Belt_Option.getExn(item.geometry);
                        var scroll$1 = Belt_Option.getExn(scroll.current);
                        var shiftedItemRect = Dnd__Geometry.shiftInternalSibling(ghost.axis, ghost.dimensions, geometry, scroll$1, container.scrollable, item.shift);
                        var currentStatus = Dnd__Geometry.isAforeAdjusted(ghost.currentRect.page, shiftedItemRect.page, ghost.axis, ghost.direction) ? "GhostIsBefore" : "GhostIsAfter";
                        var initialStatus = Dnd__Geometry.isAfore(ghost.departureRect.page, geometry.rect.page, ghost.axis) ? "GhostWasBefore" : "GhostWasAfter";
                        var match = item.shift;
                        var exit = 0;
                        if (Curry._2(Item.eq, item.id, ghost.itemId)) {
                          return [
                                  items,
                                  animate
                                ];
                        }
                        if (item.animating) {
                          return [
                                  items,
                                  animate
                                ];
                        }
                        if (match !== undefined) {
                          if (match) {
                            if (currentStatus === "GhostIsBefore") {
                              if (initialStatus === "GhostWasAfter") {
                                return [
                                        items,
                                        animate
                                      ];
                              }
                              exit = 2;
                            } else {
                              exit = 2;
                            }
                          } else if (currentStatus === "GhostIsAfter") {
                            if (initialStatus === "GhostWasBefore") {
                              return [
                                      items,
                                      animate
                                    ];
                            }
                            exit = 2;
                          } else {
                            exit = 2;
                          }
                        } else {
                          exit = 2;
                        }
                        if (exit === 2) {
                          if (currentStatus === "GhostIsAfter") {
                            if (initialStatus === "GhostWasBefore") {
                              return [
                                      Belt_Map.set(items, id, {
                                            id: item.id,
                                            containerId: item.containerId,
                                            originalIndex: item.originalIndex,
                                            targetIndex: item.originalIndex - 1 | 0,
                                            element: item.element,
                                            shift: /* Alpha */0,
                                            geometry: item.geometry,
                                            animating: true,
                                            getGeometry: item.getGeometry
                                          }),
                                      {
                                        hd: id,
                                        tl: animate
                                      }
                                    ];
                            }
                            
                          } else if (currentStatus === "GhostIsBefore" && initialStatus === "GhostWasAfter") {
                            return [
                                    Belt_Map.set(items, id, {
                                          id: item.id,
                                          containerId: item.containerId,
                                          originalIndex: item.originalIndex,
                                          targetIndex: item.originalIndex + 1 | 0,
                                          element: item.element,
                                          shift: /* Omega */1,
                                          geometry: item.geometry,
                                          animating: true,
                                          getGeometry: item.getGeometry
                                        }),
                                    {
                                      hd: id,
                                      tl: animate
                                    }
                                  ];
                          }
                          
                        }
                        if (match !== undefined) {
                          return [
                                  Belt_Map.set(items, id, {
                                        id: item.id,
                                        containerId: item.containerId,
                                        originalIndex: item.originalIndex,
                                        targetIndex: item.originalIndex,
                                        element: item.element,
                                        shift: undefined,
                                        geometry: item.geometry,
                                        animating: true,
                                        getGeometry: item.getGeometry
                                      }),
                                  {
                                    hd: id,
                                    tl: animate
                                  }
                                ];
                        } else {
                          return [
                                  items,
                                  animate
                                ];
                        }
                      }
                      if (!(Curry._2(Container.eq, targetContainerId$1, itemContainerId) && !ghost.targetingOriginalContainer)) {
                        return [
                                Belt_Map.set(items, id, {
                                      id: item.id,
                                      containerId: item.containerId,
                                      originalIndex: item.originalIndex,
                                      targetIndex: item.originalIndex,
                                      element: item.element,
                                      shift: undefined,
                                      geometry: item.geometry,
                                      animating: item.animating,
                                      getGeometry: item.getGeometry
                                    }),
                                animate
                              ];
                      }
                      var geometry$1 = Belt_Option.getExn(item.geometry);
                      var scroll$2 = Belt_Option.getExn(scroll.current);
                      var shiftedDraggableRect = Dnd__Geometry.shiftExternalSibling(ghost.axis, ghost.dimensions, geometry$1, scroll$2, container.scrollable, item.shift);
                      var currentStatus$1 = Dnd__Geometry.isAforeAdjusted(ghost.currentRect.page, shiftedDraggableRect.page, ghost.axis, ghost.direction) ? "GhostIsBefore" : "GhostIsAfter";
                      var match$1 = item.animating;
                      var match$2 = item.shift;
                      if (match$1) {
                        return [
                                items,
                                animate
                              ];
                      }
                      var exit$1 = 0;
                      if (match$2 !== undefined) {
                        if (match$2) {
                          if (currentStatus$1 === "GhostIsBefore") {
                            return [
                                    items,
                                    animate
                                  ];
                          }
                          
                        } else {
                          if (currentStatus$1 === "GhostIsAfter") {
                            return [
                                    items,
                                    animate
                                  ];
                          }
                          exit$1 = 2;
                        }
                      } else {
                        exit$1 = 2;
                      }
                      if (exit$1 === 2 && currentStatus$1 === "GhostIsBefore") {
                        return [
                                Belt_Map.set(items, id, {
                                      id: item.id,
                                      containerId: item.containerId,
                                      originalIndex: item.originalIndex,
                                      targetIndex: item.originalIndex + 1 | 0,
                                      element: item.element,
                                      shift: /* Omega */1,
                                      geometry: item.geometry,
                                      animating: true,
                                      getGeometry: item.getGeometry
                                    }),
                                {
                                  hd: id,
                                  tl: animate
                                }
                              ];
                      }
                      return [
                              Belt_Map.set(items, id, {
                                    id: item.id,
                                    containerId: item.containerId,
                                    originalIndex: item.originalIndex,
                                    targetIndex: item.originalIndex - 1 | 0,
                                    element: item.element,
                                    shift: /* Alpha */0,
                                    geometry: item.geometry,
                                    animating: true,
                                    getGeometry: item.getGeometry
                                  }),
                              {
                                hd: id,
                                tl: animate
                              }
                            ];
                    }));
            } else {
              var items$1 = Belt_Map.map(items.current, (function (item) {
                      return {
                              id: item.id,
                              containerId: item.containerId,
                              originalIndex: item.originalIndex,
                              targetIndex: item.targetIndex,
                              element: item.element,
                              shift: undefined,
                              geometry: item.geometry,
                              animating: item.animating,
                              getGeometry: item.getGeometry
                            };
                    }));
              match = [
                items$1,
                /* [] */0
              ];
            }
            var animate = match[1];
            items.current = match[0];
            Curry._1(dispatch, {
                  TAG: /* UpdateGhostPosition */2,
                  _0: ghost
                });
            Curry._1(updateScrollPosition.current, ghost);
            setTimeout((function (param) {
                    Curry._1(resetAnimationsOnDrag, animate);
                  }), Dnd__Style.animationDuration + Dnd__Style.resetAnimationsFactor | 0);
          }), [
          items,
          containers
        ]);
    var prepareDrop = React.useCallback((function (param) {
            var match = state.status;
            if (typeof match !== "number" && match.TAG === /* Dragging */1) {
              Curry._1(match._1.drop, undefined);
            }
            var frameId = scheduledWindowScrollFrameId.current;
            if (frameId !== undefined) {
              cancelAnimationFrame(Caml_option.valFromOption(frameId));
              scheduledWindowScrollFrameId.current = undefined;
            }
            var frameId$1 = scheduledScrollableElementScrollFrameId.current;
            if (frameId$1 !== undefined) {
              cancelAnimationFrame(Caml_option.valFromOption(frameId$1));
              scheduledScrollableElementScrollFrameId.current = undefined;
              return ;
            }
            
          }), [
          state.status,
          scheduledWindowScrollFrameId,
          scheduledScrollableElementScrollFrameId
        ]);
    startDropping.current = React.useCallback((function (param) {
            Curry._1(prepareDrop, undefined);
            Curry._1(dispatch, /* StartDropping */0);
          }), [prepareDrop]);
    cancelDrag.current = React.useCallback((function (param) {
            Curry._1(prepareDrop, undefined);
            items.current = Belt_Map.map(items.current, (function (item) {
                    return {
                            id: item.id,
                            containerId: item.containerId,
                            originalIndex: item.originalIndex,
                            targetIndex: item.targetIndex,
                            element: item.element,
                            shift: undefined,
                            geometry: item.geometry,
                            animating: item.animating,
                            getGeometry: item.getGeometry
                          };
                  }));
            Curry._1(dispatch, /* CancelDrag */1);
          }), [
          items,
          prepareDrop
        ]);
    React.useEffect((function () {
            var preventTouchMoveInWebkit = function ($$event) {
              var match = state.status;
              if (typeof match === "number") {
                return ;
              }
              if (match.TAG !== /* Dragging */1) {
                return ;
              }
              $$event.preventDefault();
            };
            Dnd__Events.subscribeToTouchMove(preventTouchMoveInWebkit);
            return (function (param) {
                      Dnd__Events.unsubscribeFromTouchMove(preventTouchMoveInWebkit);
                    });
          }), [state.status]);
    var match$1 = state.status;
    var tmp;
    if (typeof match$1 === "number") {
      tmp = undefined;
    } else {
      switch (match$1.TAG | 0) {
        case /* Collecting */0 :
            tmp = Caml_option.some(match$1._1);
            break;
        case /* Dragging */1 :
        case /* Dropping */2 :
            tmp = match$1._0.targetContainer;
            break;
        
      }
    }
    return React.createElement(Context.Provider.make, Curry._4(Context.Provider.makeProps, {
                    status: state.status,
                    target: tmp,
                    scroll: scroll.current,
                    registerItem: registerItem,
                    registerContainer: registerContainer,
                    disposeItem: disposeItem,
                    disposeContainer: disposeContainer,
                    getItemShift: (function (itemId) {
                        return Belt_Map.getExn(items.current, itemId).shift;
                      }),
                    startDragging: collectEntries
                  }, children, undefined, undefined));
  };
  return {
          Item: Item,
          Container: Container,
          ComparableItem: ComparableItem,
          ComparableContainer: ComparableContainer,
          Layout: Layout,
          MouseSubscriptions: MouseSubscriptions,
          TouchSubscriptions: TouchSubscriptions,
          Hook: Hook,
          make: Dnd__DndManager$Make
        };
}

var Context;

var Events;

var Style;

var Geometry;

var Scroller;

var Scrollable;

var Web;

export {
  Context ,
  Events ,
  Style ,
  Geometry ,
  Scroller ,
  Scrollable ,
  Web ,
  Make ,
}
/* react Not a pure module */
